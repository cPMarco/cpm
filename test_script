#!/usr/bin/perl
# Here's the bash one-liner.  It's described at:
# https://staffwiki.cpanel.net/bin/view/LinuxSupport/OneLiners#Both_of_above_two_one_45liners_combined_into_one
# 
## Set time between chksrvd checks that's NOT a problem.  Ie. anything more, and show the 'took too long' error:
# every_n_min=10;
## Just get the last x lines.  Otherwise, the check will take a long time.
# tail -12000 /var/log/chkservd.log | awk -v n=$every_n_min '{
#     # If the first field is a date...
#     if ($1~/\[20/) 
#      # Then set the date (happens constantly):
#      lastdate=$1" "$2" "$3;
#      # Check the time period for the 'took too long' error:
#      split($2,curdate,":");
#      dmin=(curdate[2]-lastmin);
#      dhr=(curdate[1]-lasthr);
#      # If there's problems on this line, except for certain ones:
#      if ($0!~/Restarting|nable|\*\*|imeout|ailure|terrupt/ && $0~/:-]/) 
#         # Then first print the last date seen
#         print lastdate".....";
#         # Run through each field in the line:
#         for (i=1; i<=NF; i=i+1) 
#             # If there's a problem
#             if ($i~/Restarting|nable|\*\*|imeout|ailure|terrupt|100%|9[89]%|second/) 
#                 # And if the first field is a date, print the date and error, and the surrounding fields for more info
#                 if ($1~/\[20/) print $1,$2,$3,$(i-1),$i,$(i+1);
#             # Otherwise print the last date and the error, and the surrounding fields for more info
#             else print lastdate,$(i-1),$i,$(i+1);
#         # Check for 'took too long'.  Print if found.
#         if($1~/\[20/ && (lastmin!=0 || lasthr!=0) && (dmin>n || (dhr==1 && (dmin>-(60-n))) || dhr>1 )) print $1,$2,$3" check took longer than "n" minutes. (hr:min): "dhr":"dmin;
#     if ($1~/\[20/) {lastmin=curdate[2]; lasthr=curdate[1]} 
# }'

use Data::Dumper;

# Here's 3 major steps I need to do:
#1.) open log file
open my $file, 'chkservd.log' or die "couldn't open file $!";


#2.) make a for loop that reads the file

# foreach my $line (readline $file) {

#3.) break file into hash of hashes called "service_status"
# not sure what this means 
# maybe Ill separate everything by at least two dots together (..) so, if the block contains "-]", then the check failed, and I can print the whole block.

my %hash = do {
  local $/; # set to undef, for slurp
  map {
    my ($key, $vals) = split /\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2} \+[0-9]{4}\]/, $_, 2; # split on first whitespace, into two strings
    $key => [ split /\s*\.\.\.\.\s*/, $vals ];    # return a list of a key and a value array
  } split /(?<!,)\n/, <FILE>;              # split the file into records
};

# # just getting some of the lines using the old regex
#     if ($line =~ /Restarting|nable|\*\*|imeout|ailure|terrupt|100%|9[89]%|second/){
#         print $line
#     }
# }


# http://stackoverflow.com/questions/15476540/perl-parse-file-text-into-hash



# for each element in "service_status", parse services found (into subhash)
#   use my templog="bit of the log"
#  extract status of each service as one variable
#  




close $file;




#$service_status->{'2012-08-05 12:38:47'}->{'mysql'} = "Mysql failed to connect";
