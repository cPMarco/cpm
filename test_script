#!/usr/bin/perl
# Here's the bash one-liner.  It's described at:
# https://staffwiki.cpanel.net/bin/view/LinuxSupport/OneLiners#Both_of_above_two_one_45liners_combined_into_one
# 
## Set time between chksrvd checks that's NOT a problem.  Ie. anything more, and show the 'took too long' error:
# every_n_min=10;
## Just get the last x lines.  Otherwise, the check will take a long time.
# tail -12000 /var/log/chkservd.log | awk -v n=$every_n_min '{
#     # If the first field is a date...
#     if ($1~/\[20/) 
#      # Then set the date (happens constantly):
#      lastdate=$1" "$2" "$3;
#      # Check the time period for the 'took too long' error:
#      split($2,curdate,":");
#      dmin=(curdate[2]-lastmin);
#      dhr=(curdate[1]-lasthr);
#      # If there's problems on this line, except for certain ones:
#      if ($0!~/Restarting|nable|\*\*|imeout|ailure|terrupt/ && $0~/:-]/) 
#         # Then first print the last date seen
#         print lastdate".....";
#         # Run through each field in the line:
#         for (i=1; i<=NF; i=i+1) 
#             # If there's a problem
#             if ($i~/Restarting|nable|\*\*|imeout|ailure|terrupt|100%|9[89]%|second/) 
#                 # And if the first field is a date, print the date and error, and the surrounding fields for more info
#                 if ($1~/\[20/) print $1,$2,$3,$(i-1),$i,$(i+1);
#             # Otherwise print the last date and the error, and the surrounding fields for more info
#             else print lastdate,$(i-1),$i,$(i+1);
#         # Check for 'took too long'.  Print if found.
#         if($1~/\[20/ && (lastmin!=0 || lasthr!=0) && (dmin>n || (dhr==1 && (dmin>-(60-n))) || dhr>1 )) print $1,$2,$3" check took longer than "n" minutes. (hr:min): "dhr":"dmin;
#     if ($1~/\[20/) {lastmin=curdate[2]; lasthr=curdate[1]} 
# }'


# Here's 3 major steps I need to do:
#1.) open log file
open my $file, 'chkservd.log' or die "couldn't open file $!";


#2.) make a for loop that reads the file
my $lastdate="how bout text";
foreach my $line (readline $file) {

#3.) break file into hash of hashes called "service_status"
# not sure what this means 
# maybe Ill separate everything by at least two dots together (..) so, if the block contains "-]", then the check failed, and I can print the whole block.

# Set the date
$lastdate = $1 if $line =~ /(\[[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2} \+[0-9]{4}\]).*/ ;
#DEBUG
#print $lastdate ;

# getting the lines using the old regex
    if ($line !~ /Restarting|nable|\*\*|imeout|ailure|terrupt|100%|9[89]%|second/ && $line =~ /:\-\]/){
            print $lastdate, " ....\n";
        }
    if ($line =~ /Restarting|nable|\*\*|imeout|ailure|terrupt|100%|9[89]%|second/){
        @a1 = split /(\.){2,}/,$line;
        foreach (@a1) {
            if (/:\-\]/) {
                print $lastdate, " ", $_, "\n";
            }
        }
        #DEBUG print "\nFOR LOOP DONE\n";
    }
}



# couple things to try here, although they don't show how to go through the data
# http://stackoverflow.com/questions/15476540/perl-parse-file-text-into-hash



# for each element in "service_status", parse services found (into subhash)
#   use my templog="bit of the log"
#  extract status of each service as one variable
#  




close $file;




#$service_status->{'2012-08-05 12:38:47'}->{'mysql'} = "Mysql failed to connect";
